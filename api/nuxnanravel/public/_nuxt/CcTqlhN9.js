import{N as V,aq as F,C as H,ar as m,a2 as L,as as q,g as U,Y as W,a4 as M,at as j,au as z,r as I,B as p,av as G,a5 as Y,aw as J,u as Q,ax as X}from"./DuB962GZ.js";import{c as Z}from"./Dy2WcBMD.js";const $={trailing:!0};function A(a,e=25,i={}){if(i={...$,...i},!Number.isFinite(e))throw new TypeError("Expected `wait` to be a finite number");let o,r,D=[],n,t;const v=(f,h)=>(n=x(a,f,h),n.finally(()=>{if(n=null,i.trailing&&t&&!r){const g=v(f,t);return t=null,g}}),n),b=function(...f){return i.trailing&&(t=f),n||new Promise(h=>{const g=!r&&i.leading;clearTimeout(r),r=setTimeout(()=>{r=null;const c=i.leading?o:v(this,f);t=null;for(const d of D)d(c);D=[]},e),g?(o=v(this,f),h(o)):D.push(h)})},s=f=>{f&&(clearTimeout(f),r=null)};return b.isPending=()=>!!r,b.cancel=()=>{s(r),D=[],t=null},b.flush=()=>{if(s(r),!t||n)return;const f=t;return t=null,v(this,f)},b}async function x(a,e,i){return await a.apply(e,i)}const K=a=>a==="defer"||a===!1;function sa(...a){const e=typeof a[a.length-1]=="string"?a.pop():void 0;k(a[0],a[1])&&a.unshift(e);let[i,o,r={}]=a,D=!1;const n=V(()=>F(i));if(typeof n.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof o!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const t=H();r.server??=!0,r.default??=ea,r.getCachedData??=N,r.lazy??=!1,r.immediate??=!0,r.deep??=m.deep,r.dedupe??="cancel",r._functionName,t._asyncData[n.value];function v(){const c={cause:"initial",dedupe:r.dedupe};return t._asyncData[n.value]?._init||(c.cachedData=r.getCachedData(n.value,t,{cause:"initial"}),t._asyncData[n.value]=T(t,n.value,o,r,c.cachedData)),()=>t._asyncData[n.value].execute(c)}const b=v(),s=t._asyncData[n.value];s._deps++;const f=r.server!==!1&&t.payload.serverRendered;{let c=function(u){const l=t._asyncData[u];l?._deps&&(l._deps--,l._deps===0&&l?._off())};const d=L();if(d&&f&&r.immediate&&!d.sp&&(d.sp=[]),d&&!d._nuxtOnBeforeMountCbs){d._nuxtOnBeforeMountCbs=[];const u=d._nuxtOnBeforeMountCbs;q(()=>{u.forEach(l=>{l()}),u.splice(0,u.length)}),U(()=>u.splice(0,u.length))}const E=d&&(d._nuxtClientOnly||W(Z,!1));f&&t.isHydrating&&(s.error.value||s.data.value!=null)?(s.pending.value=!1,s.status.value=s.error.value?"error":"success"):d&&(!E&&t.payload.serverRendered&&t.isHydrating||r.lazy)&&r.immediate?d._nuxtOnBeforeMountCbs.push(b):r.immediate&&b();const _=z(),y=M(n,(u,l)=>{if((u||l)&&u!==l){D=!0;const O=t._asyncData[l]?.data.value!==m.value,R=t._asyncDataPromises[l]!==void 0,S={cause:"initial",dedupe:r.dedupe};if(!t._asyncData[u]?._init){let P;l&&O?P=t._asyncData[l].data.value:(P=r.getCachedData(u,t,{cause:"initial"}),S.cachedData=P),t._asyncData[u]=T(t,u,o,r,P)}t._asyncData[u]._deps++,l&&c(l),(r.immediate||O||R)&&t._asyncData[u].execute(S),X(()=>{D=!1})}},{flush:"sync"}),C=r.watch?M(r.watch,()=>{D||t._asyncData[n.value]?._execute({cause:"watch",dedupe:r.dedupe})}):()=>{};_&&j(()=>{y(),C(),c(n.value)})}const h={data:w(()=>t._asyncData[n.value]?.data),pending:w(()=>t._asyncData[n.value]?.pending),status:w(()=>t._asyncData[n.value]?.status),error:w(()=>t._asyncData[n.value]?.error),refresh:(...c)=>t._asyncData[n.value]?._init?t._asyncData[n.value].execute(...c):v()(),execute:(...c)=>h.refresh(...c),clear:()=>{const c=t._asyncData[n.value];if(c?._abortController)try{c._abortController.abort(new DOMException("AsyncData aborted by user.","AbortError"))}finally{c._abortController=void 0}B(t,n.value)}},g=Promise.resolve(t._asyncDataPromises[n.value]).then(()=>h);return Object.assign(g,h),g}function w(a){return V({get(){return a()?.value},set(e){const i=a();i&&(i.value=e)}})}function k(a,e){return!(typeof a=="string"||typeof a=="object"&&a!==null||typeof a=="function"&&typeof e=="function")}function B(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=m.errorValue),a._asyncData[e]&&(a._asyncData[e].data.value=void 0,a._asyncData[e].error.value=m.errorValue,a._asyncData[e].pending.value=!1,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]=void 0)}function aa(a,e){const i={};for(const o of e)i[o]=a[o];return i}function T(a,e,i,o,r){a.payload._errors[e]??=m.errorValue;const D=o.getCachedData!==N,n=i,t=o.deep?I:p,v=r!=null,b=a.hook("app:data:refresh",async f=>{(!f||f.includes(e))&&await s.execute({cause:"refresh:hook"})}),s={data:t(v?r:o.default()),pending:p(!v),error:G(a.payload._errors,e),status:p("idle"),execute:(...f)=>{const[h,g=void 0]=f,c=h&&g===void 0&&typeof h=="object"?h:{};if(a._asyncDataPromises[e]&&K(c.dedupe??o.dedupe))return a._asyncDataPromises[e];if(c.cause==="initial"||a.isHydrating){const _="cachedData"in c?c.cachedData:o.getCachedData(e,a,{cause:c.cause??"refresh:manual"});if(_!=null)return a.payload.data[e]=s.data.value=_,s.error.value=m.errorValue,s.status.value="success",Promise.resolve(_)}s.pending.value=!0,s._abortController&&s._abortController.abort(new DOMException("AsyncData request cancelled by deduplication","AbortError")),s._abortController=new AbortController,s.status.value="pending";const d=new AbortController,E=new Promise((_,y)=>{try{const C=c.timeout??o.timeout,u=ta([s._abortController?.signal,c?.signal],d.signal,C);if(u.aborted){const l=u.reason;y(l instanceof Error?l:new DOMException(String(l??"Aborted"),"AbortError"));return}return u.addEventListener("abort",()=>{const l=u.reason;y(l instanceof Error?l:new DOMException(String(l??"Aborted"),"AbortError"))},{once:!0,signal:d.signal}),Promise.resolve(n(a,{signal:u})).then(_,y)}catch(C){y(C)}}).then(async _=>{let y=_;o.transform&&(y=await o.transform(_)),o.pick&&(y=aa(y,o.pick)),a.payload.data[e]=y,s.data.value=y,s.error.value=m.errorValue,s.status.value="success"}).catch(_=>{if(a._asyncDataPromises[e]&&a._asyncDataPromises[e]!==E||s._abortController?.signal.aborted)return a._asyncDataPromises[e];if(typeof DOMException<"u"&&_ instanceof DOMException&&_.name==="AbortError")return s.status.value="idle",a._asyncDataPromises[e];s.error.value=J(_),s.data.value=Q(o.default()),s.status.value="error"}).finally(()=>{s.pending.value=!1,d.abort(),delete a._asyncDataPromises[e]});return a._asyncDataPromises[e]=E,a._asyncDataPromises[e]},_execute:A((...f)=>s.execute(...f),0,{leading:!0}),_default:o.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{b(),a._asyncData[e]?._init&&(a._asyncData[e]._init=!1),D||Y(()=>{a._asyncData[e]?._init||(B(a,e),s.execute=()=>Promise.resolve(),s.data.value=m.value)})}};return s}const ea=()=>m.value,N=(a,e,i)=>{if(e.isHydrating)return e.payload.data[a];if(i.cause!=="refresh:manual"&&i.cause!=="refresh:hook")return e.static.data[a]};function ta(a,e,i){const o=a.filter(n=>!!n);if(typeof i=="number"&&i>=0){const n=AbortSignal.timeout?.(i);n&&o.push(n)}if(AbortSignal.any)return AbortSignal.any(o);const r=new AbortController;for(const n of o)if(n.aborted){const t=n.reason??new DOMException("Aborted","AbortError");try{r.abort(t)}catch{r.abort()}return r.signal}const D=()=>{const t=o.find(v=>v.aborted)?.reason??new DOMException("Aborted","AbortError");try{r.abort(t)}catch{r.abort()}};for(const n of o)n.addEventListener?.("abort",D,{once:!0,signal:e});return r.signal}export{sa as u};
